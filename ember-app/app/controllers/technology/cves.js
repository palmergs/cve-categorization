import Ember from 'ember';
import AssessmentColumn from '../../models/assessment-column';

export default Ember.Controller.extend({
  store: Ember.inject.service(),

  queryCount: 0,
  isProcessing: Ember.computed('queryCount', function() {
    return this.get('queryCount') > 0
  }),

  currentQueryString: null,
  currentQueryYear: null,

  userRejected: AssessmentColumn.create({ data: Ember.A() }),
  userSelected: AssessmentColumn.create({ data: Ember.A() }),
  uncategorized: AssessmentColumn.create({ data: Ember.A() }),
  termUnlikely: AssessmentColumn.create({ data: Ember.A() }),
  termLikely: AssessmentColumn.create({ data: Ember.A() }),

  loadColumns: Ember.on('init', Ember.observer('model', function() {
    if(this.get('model.id')) {
      this.resetForCategory(-2);
      this.resetForCategory(-1);
      this.resetForCategory( 0);
      this.resetForCategory( 1);
      this.resetForCategory( 2);
    }
  })),

  queryForCategory(category, resetPage) {
    const column = this.columnForCategory(category);
    const page = (column.get('meta.page') && !resetPage) ? column.get('meta.page') + 1 : null;
    return this.get('store').query('assessment', {
      technology_id: this.get('model.id'),
      p: page,
      filter: {
        assess: category,
        year: this.get('currentQueryYear'),
        q: this.get('currentQueryString')
      }
    });
  },

  columnForCategory(category) {
    switch(category) {
      case -2: return this.get('userRejected');
      case -1: return this.get('termUnlikely');
      case  0: return this.get('uncategorized');
      case  1: return this.get('termLikely');
      case  2: return this.get('userSelected');
    }
  },

  appendForCategory(category) {
    this.incrementProperty('queryCount');
    this.queryForCategory(category).then((results) => {
      this.decrementProperty('queryCount');
      const column = this.columnForCategory(category);

      column.get('data').addObjects(results);
      column.set('meta', results.meta.pagination);
    }, () => {
      this.decrementProperty('queryCount');
    });
  },

  resetForCategory(category) {
    this.incrementProperty('queryCount');
    this.queryForCategory(category, true).then((results) => {
      this.decrementProperty('queryCount');
      const column = this.columnForCategory(category);

      column.get('data').clear();
      column.get('data').addObjects(results);
      column.set('meta', results.meta.pagination);
    }, () => {
      this.decrementProperty('queryCount');
    });
  },

  actions: {
    onAssessmentChanged(assessment) {
      const category = assessment.get('assessment');
      const column = this.columnForCategory(category);
      column.incrementProperty('meta.total');
      column.get('data').pushObject(assessment);
    },

    onLoadMore(category) {
      this.appendForCategory(category);
    },

    onTermAdded(string, value) {
      const technology = this.get('model');
      let term = this.get('store').createRecord('term', {
        technology: technology,
        term: string,
        value: value
      });

      this.incrementProperty('queryCount');
      term.save().then(() => {
        this.decrementProperty('queryCount');
        this.resetForCategory(-1);
        this.resetForCategory( 0);
        this.resetForCategory( 1);
      }, () => {
        this.decrementProperty('queryCount');
      });
    },

    onYearChange(value) {
      this.set('currentQueryYear', value);
      this.resetForCategory(-2);
      this.resetForCategory(-1);
      this.resetForCategory( 0);
      this.resetForCategory( 1);
      this.resetForCategory( 2);
    },

    onQueryChange(value) {
      this.set('currentQueryString', value);
      this.resetForCategory(-2);
      this.resetForCategory(-1);
      this.resetForCategory( 0);
      this.resetForCategory( 1);
      this.resetForCategory( 2);
    },

    onColumnClicked(assess, model) {
      const selected = this.get('selectedAssess');
      if(selected) {
        this.set('selectedAssess', null);
        this.set('selectedModel', null);
      } else {
        this.set('selectedAssess', assess);
        this.set('selectedModel', model);
      }
    }
  }
});
